<?php
/*
 *  @company DarcFlow design [https://darcflow.com]
 *  @author    Koroph <yjk@outlook.fr> {(+225)0778329592}
 *  @website http://koroph.site
 *  @link      https://github.com/Koroph
 *  @license   Apache 2.0
 *  @Copyright (c) 2021.
 *
 */

namespace App\Controller;


use App\Controller\Utils\FileUploader;
use App\Controller\Utils\Notice;
use App\Controller\Utils\Paginate;
use App\Controller\Utils\Query;
use App\Entity\Directory;
use App\Entity\Files;
use Doctrine\DBAL\Connection;
use Doctrine\DBAL\Exception;
use Doctrine\DBAL\Result;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\File\UploadedFile;
use Symfony\Component\HttpFoundation\RedirectResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\String\Slugger\SluggerInterface;
use Symfony\Component\Validator\Validator\ValidatorInterface;
use Symfony\Component\Yaml\Parser as YamlParser;


abstract class BaseController extends AbstractController
{

    protected $viewPath;
    protected $csrf_create;
    protected $csrf_update;
    protected $image_upload_field = '_image';
    protected const IMAGE_RESIZE_SIZE_KEY = "app.image_resize_size";
    protected const STORAGE_FOLDER_KEY = "app.storage_dir";
    protected const PAGINATE_COUNT_KEY = "app.paginate_count";
    protected const ERROR_FILE_PATH_KEY = "app.error_message_file";
    protected const APP_URL_KEY = "app.url";
    protected const PAGE_PARAM = "page";
    protected const CRSF_INVALIDE_MESSAGE = "Le token crsf est invalide...!";

    use FileUploader;

    protected function render(string $view, array $parameters = [], Response $response = null): Response
    {

        return parent::render(str_replace('>', '/', $this->viewPath . $view) . '.html.twig', $parameters, $response); // TODO: Change the autogenerated stub
    }

    /**
     * @param Request $request
     * @param Directory $directory
     * @param SluggerInterface $slugger
     * @param string|null $type
     * @return Files|null
     */
    protected function uploadImage(Request $request, Directory $directory, SluggerInterface $slugger, ?string $type = 'image'): ?Files
    {

        if (!is_null($request->files->get($this->image_upload_field))) {
            $files = new Files();
            /**
             * @var $file UploadedFile
             */
            foreach ($request->files->all() as $file) {
                $_file_info = $this->fileUpload($file, $directory, $slugger, self::STORAGE_FOLDER_KEY, $type);
                $files->setPath($_file_info['path']);
                $files->setUrl($_file_info['url']);
                $files->setType($type);
                $files->setTitle(substr($file->getClientOriginalName(), 0, strrpos($file->getClientOriginalName(), '.')));
                $files->setDirectory($directory);
                break;
            }
            return $files;
        } else return null;
    }


    /**
     * @param Request $request
     * @param string $name
     * @return RedirectResponse
     */
    protected function redirectAfterStore(Request $request, string $name): RedirectResponse
    {
        if ($request->request->get('_btn') === 'c')
            return $this->redirect($request->getUri(), Response::HTTP_SEE_OTHER);
        else return $this->redirectToRoute("$name.index", [], Response::HTTP_SEE_OTHER);
    }

    /**
     * @param $receive
     * @param int|null $count
     * @return Paginate
     */
    protected function paginate($receive, int $count = null): Paginate
    {

        $index = (isset($_GET['page']) && !empty($_GET['page'])) ? intval($_GET['page']) : 1;

        $paginateCount = $count ?? $this->getParameter(self::PAGINATE_COUNT_KEY);
        $send = new Paginate();
        $_data = array_chunk($receive, $paginateCount);

        if ($index < 0) $index = 1;
        if ($index > count($_data)) $index = count($_data) - 1;

        $send->setData(count($receive) > 0 ? $_data[$index - 1] : []);
        $send->setIndex($index);
        $send->setState(count($_data));
        $send->setAllCount(count($receive));

        return $send;
    }

    /**
     * @param $_entity
     * @param ValidatorInterface $validator
     * @param bool $isUpdate
     * @return bool
     */
    public function validator($_entity, ValidatorInterface $validator, bool $isUpdate = false): bool
    {
        $groups = $isUpdate ? "update" : "register";
        $errors = $validator->validate($_entity, null, $groups);

        if (count($errors) > 0) {
            $this->addFlash(Notice::KEY_WARNING, $this->getErrorMessage($errors->get(0)->getMessage()));
            $this->addFlash(Notice::KEY_ERRORS, $errors->get(0)->getRoot());
        }
        return count($errors) === 0;
    }

    /**
     * @param string $raw
     * @return string|string[]
     */
    private function getErrorMessage(string $raw)
    {
        if (strpos($raw, ":") !== false) {
            $parser = new YamlParser();
            $_raw = explode(":", $raw);
            $_data = $parser->parseFile($this->getParameter(self::ERROR_FILE_PATH_KEY));
            return str_replace('+attribute', current($_raw), $_data[end($_raw)]);
        } else return $raw;

    }

    /**
     * @return array[]
     * @throws Exception|\Doctrine\DBAL\Driver\Exception
     */
    protected function getStudentData(): array
    {
        /**
         * @var $connection Connection
         */
        $connection = $this->getDoctrine()
            ->getConnection();

        $stmt = $connection->prepare(Query::STUDENT_SELECT_BY_NAME_AND_MATRICULE);

       return $stmt->executeQuery()->fetchAllAssociative();
    }

}